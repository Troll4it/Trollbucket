package com.troll.bus.flowimport androidx.lifecycle.LifecycleOwnerimport androidx.lifecycle.lifecycleScopeimport com.troll.bus.AbstractBusimport com.troll.bus.Eventimport kotlinx.coroutines.*import kotlinx.coroutines.channels.BufferOverflowimport kotlinx.coroutines.flow.MutableSharedFlowimport kotlinx.coroutines.flow.takeimport troll.btc.extensions.launchopen class FlowBus : AbstractBus() {    private val superScope: CoroutineScope = MainScope()    private val flow = MutableSharedFlow<Event<*>>(        replay = 0,        extraBufferCapacity = 0,        onBufferOverflow = BufferOverflow.SUSPEND    )    override fun send(event: Event<*>) {        superScope.launch(Dispatchers.Default) {            flow.emit(event)        }    }    override fun createObserver(owner: LifecycleOwner): Observer {        return ObserverImpl(owner.lifecycleScope)    }    override fun createObserver(scope: CoroutineScope): Observer {        return ObserverImpl(scope)    }    override fun createObserver(): Observer {        return ObserverImpl(null)    }    override fun createObserver(count: Int): Observer {        return ObserverImpl(null, count)    }    override fun release() {        superScope.cancel()    }    internal inner class ObserverImpl(        private val scope: CoroutineScope?,        private val takeCount: Int = -1    ) : Observer {        override fun <T> onValue(eventId: Int, action: (T) -> Unit) {            this@FlowBus.onValue(scope, takeCount, eventId, action)        }        override fun <T> onNullableValue(eventId: Int, action: (T?) -> Unit) {            this@FlowBus.onNullableValue(scope, takeCount, eventId, action)        }        override fun <R : Event<*>> onEvent(eventId: Int, action: (R) -> Unit) {            this@FlowBus.onEvent(scope, takeCount, eventId, action)        }        override fun onMessage(eventId: Int, action: () -> Unit) {            this@FlowBus.onMessage(scope, takeCount, eventId, action)        }    }    private fun <T> onValue(        scope: CoroutineScope?,        takeCount: Int,        eventId: Int,        action: (T) -> Unit    ) {        launch(scope, takeCount) { e ->            if (e.eventId == eventId) {                val cast: T = e.any as? T ?: return@launch                action(cast)            }        }    }    private fun <T> onNullableValue(        scope: CoroutineScope?,        takeCount: Int,        eventId: Int,        action: (T?) -> Unit    ) {        launch(scope, takeCount) { e ->            if (e.eventId == eventId) {                val cast: T? = e.any as? T?                action(cast)            }        }    }    private fun <R : Event<*>> onEvent(        scope: CoroutineScope?,        takeCount: Int,        eventId: Int,        action: (R) -> Unit    ) {        launch(scope, takeCount) { e ->            if (e.eventId == eventId) {                val cast: R = e as? R ?: return@launch                action(cast)            }        }    }    private fun onMessage(        scope: CoroutineScope?,        takeCount: Int,        eventId: Int,        action: () -> Unit    ) {        launch(scope, takeCount) { e ->            if (e.eventId == eventId) action()        }    }    private fun launch(scope: CoroutineScope?, takeCount: Int, action: (Event<*>) -> Unit) {        val useFlow = if (takeCount > 0) flow.take(takeCount) else flow        useFlow.launch(scope ?: superScope, Dispatchers.Main) {            action(it)        }    }}