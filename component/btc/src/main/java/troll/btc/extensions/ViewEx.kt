package troll.btc.extensionsimport android.graphics.Colorimport android.graphics.drawable.GradientDrawableimport android.text.Editableimport android.text.TextWatcherimport android.view.Viewimport android.widget.EditTextimport android.widget.TextView/** * https://juejin.cn/post/6921337734216810504 */fun View.setRoundBackground(    backgroundColor: Int = Color.WHITE,    radiu: Float = 0f,    strokeColor: Int = Color.TRANSPARENT,    strokeWidth: Int = 0) {    background = GradientDrawable().apply {        setBackgroundColor(backgroundColor)        setStroke(strokeWidth, strokeColor)        cornerRadius = radiu    }}fun EditText.onTextChange(afterTextChanged: (s: Editable?) -> Unit) {    this.addTextChangedListener(object : TextWatcher {        override fun afterTextChanged(s: Editable?) {            afterTextChanged.invoke(s)        }        override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {        }        override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {        }    })}fun View?.show() {    this?.apply {        if (visibility != View.VISIBLE) {            visibility = View.VISIBLE        }    }}fun View?.gone() {    this?.apply {        if (visibility != View.GONE) {            visibility = View.GONE        }    }}fun View?.hide() {    this?.apply {        if (visibility != View.INVISIBLE) {            visibility = View.INVISIBLE        }    }}fun View?.showOrGone(b: Boolean) {    if (b) {        this.show()    } else {        this.gone()    }}fun View?.showOrHide(b: Boolean) {    if (b) {        this.show()    } else {        this.hide()    }}fun <T : View> T?.onClick(block: () -> Unit) {    this?.setOnClickListener {        block()    }}fun <T : View> T?.onSingleClick(block: () -> Unit) {    this?.setOnClickListener(object : SingleClickListener() {        override fun onSingleClick(v: View) {            block()        }    })}fun View.resize(height: Int, width: Int) {    val params = layoutParams    params.height = height    params.width = width    layoutParams = params}private abstract class SingleClickListener : View.OnClickListener {    companion object {        const val MIN_CLICK_INTERVAL = 500    }    private var lastClickTime: Long = 0    override fun onClick(v: View) {        val currentTime = System.currentTimeMillis()        if (currentTime - lastClickTime > MIN_CLICK_INTERVAL) {            lastClickTime = currentTime;            onSingleClick(v)        }    }    abstract fun onSingleClick(v: View)}private abstract class RepeatedlyClick : View.OnClickListener {    private val clickInterval = 2000    private val maxCount = 10    private val originCount = 0    private var firstClickTime: Long = 0    private var count: Int = 0    override fun onClick(v: View) {        val currentTime = System.currentTimeMillis()        when (count) {            originCount -> {                firstClickTime = currentTime            }            maxCount -> {                count = originCount                if (currentTime - currentTime < clickInterval)                    onRepeatedlyClick(v)            }            else -> {                count++            }        }    }    abstract fun onRepeatedlyClick(v: View)}inline fun TextView.addTextChangeListener(    crossinline beforeTextChange: (CharSequence?, Int, Int, Int) -> Unit = { _, _, _, _ -> },    crossinline onTextChanged: (CharSequence?, Int, Int, Int) -> Unit = { _, _, _, _ -> },    crossinline afterTextChanged: (Editable?) -> Unit = {}) {    val listener = object : TextWatcher {        override fun beforeTextChanged(c: CharSequence?, start: Int, count: Int, after: Int) {            beforeTextChange.invoke(c, start, count, after)        }        override fun onTextChanged(c: CharSequence?, start: Int, count: Int, after: Int) {            onTextChanged.invoke(c, start, count, after)        }        override fun afterTextChanged(p0: Editable?) {            afterTextChanged.invoke(p0)        }    }    this.addTextChangedListener(listener)}