package troll.btc.extensionsimport androidx.lifecycle.Lifecycleimport androidx.lifecycle.LifecycleOwnerimport androidx.lifecycle.lifecycleScopeimport androidx.lifecycle.repeatOnLifecycleimport kotlinx.coroutines.*import kotlinx.coroutines.flow.*import kotlin.reflect.KProperty1/** * author : TangPeng * description : Flow 的拓展 */internal data class StateTuple1<A>(val a: A)fun <T> MutableStateFlow<T>.setState(reducer: T.() -> T) {    this.value = this.value.reducer()}fun <T, A> StateFlow<T>.observeState(    lifecycleOwner: LifecycleOwner,    property1: KProperty1<T, A>,    action: (A) -> Unit) {    lifecycleOwner.lifecycleScope.launch {        lifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {            this@observeState.map {                property1.get(it)            }.distinctUntilChanged() // 这个会去重，一样的不会去发送                .collect {                    action.invoke(it)                }        }    }}// 别名typealias SharedFlowEvents<T> = MutableSharedFlow<List<T>>@Suppress("FunctionName")fun <T> SharedFlowEvents(): SharedFlowEvents<T> {    return MutableSharedFlow()}/** * 转List的考虑 ，可以利用多个Event 考虑 */fun <T> SharedFlow<List<T>>.observeEvent(lifecycleOwner: LifecycleOwner, action: (T) -> Unit) {    lifecycleOwner.lifecycleScope.launchWhenStarted {        this@observeEvent.collect {            it.forEach { event ->                action.invoke(event)            }        }    }}suspend fun <T> SharedFlowEvents<T>.flowEvent(vararg values: T) {    val eventList = values.toList()    this.emit(eventList)}fun countDown(    total: Int, scope: CoroutineScope,    onTick: ((Int) -> Unit)? = null,    onStart: (() -> Unit)? = null,    onCompletion: (() -> Unit)? = null,    onCancel: (() -> Unit)? = null,): Job {    return flow {        for (i in total downTo 0) {            emit(i)            delay(1000)        }    }.flowOn(Dispatchers.Main)        .catch {            println("异常")        }        .onStart { onStart?.invoke() }        .onCompletion { throwable ->            if (throwable == CancellationException()) {                onCancel?.invoke()            } else {                onCompletion?.invoke()            }        }        .onEach { onTick?.invoke(it) }        .launchIn(scope)}