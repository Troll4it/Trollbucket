package troll.btc.extensionsimport androidx.lifecycle.Lifecycleimport androidx.lifecycle.LifecycleOwnerimport androidx.lifecycle.lifecycleScopeimport androidx.lifecycle.repeatOnLifecycleimport kotlinx.coroutines.CancellationExceptionimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.Jobimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.Flowimport kotlinx.coroutines.flow.MutableSharedFlowimport kotlinx.coroutines.flow.MutableStateFlowimport kotlinx.coroutines.flow.SharedFlowimport kotlinx.coroutines.flow.StateFlowimport kotlinx.coroutines.flow.catchimport kotlinx.coroutines.flow.distinctUntilChangedimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.flowOnimport kotlinx.coroutines.flow.launchInimport kotlinx.coroutines.flow.mapimport kotlinx.coroutines.flow.onCompletionimport kotlinx.coroutines.flow.onEachimport kotlinx.coroutines.flow.onStartimport kotlinx.coroutines.launchimport kotlin.reflect.KProperty1/** * author : TangPeng * description : Flow 的拓展 */internal data class StateTuple1<A>(val a: A)fun <T> MutableStateFlow<T>.setState(reducer: T.() -> T) {    this.value = this.value.reducer()}fun <T> Flow<T>.observe(    lifecycleOwner: LifecycleOwner,    action: (T) -> Unit) {    lifecycleOwner.lifecycleScope.launch {        lifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {            this@observe.collect {                action.invoke(it)            }        }    }}fun <T, A> StateFlow<T>.observeState(    lifecycleOwner: LifecycleOwner,    property1: KProperty1<T, A>,    action: (A) -> Unit) {    lifecycleOwner.lifecycleScope.launch {        lifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {            this@observeState.map {                property1.get(it)            }.distinctUntilChanged() // 这个会去重，一样的不会去发送                .collect {                    action.invoke(it)                }        }    }}// 别名typealias SharedFlowEvents<T> = MutableSharedFlow<List<T>>@Suppress("FunctionName")fun <T> SharedFlowEvents(): SharedFlowEvents<T> {    return MutableSharedFlow()}/** * 转List的考虑 ，可以利用多个Event 考虑 */fun <T> SharedFlow<List<T>>.observeEvent(lifecycleOwner: LifecycleOwner, action: (T) -> Unit) {    lifecycleOwner.lifecycleScope.launchWhenStarted {        this@observeEvent.collect {            it.forEach { event ->                action.invoke(event)            }        }    }}suspend fun <T> SharedFlowEvents<T>.flowEvent(vararg values: T) {    val eventList = values.toList()    this.emit(eventList)}fun countDown(    total: Int, scope: CoroutineScope,    onTick: ((Int) -> Unit)? = null,    onStart: (() -> Unit)? = null,    onCompletion: (() -> Unit)? = null,    onCancel: (() -> Unit)? = null,): Job {    return flow {        for (i in total downTo 0) {            emit(i)            delay(100)        }    }.flowOn(Dispatchers.Main)        .catch {            println("异常")        }        .onStart { onStart?.invoke() }        .onCompletion { throwable ->            if (throwable == CancellationException()) {                onCancel?.invoke()            } else {                onCompletion?.invoke()            }        }        .onEach { onTick?.invoke(it) }        .launchIn(scope)}/** * 判断两次事务的时间 */fun <T> Flow<T>.throttleFirst(thresholdMillis: Long = 500): Flow<T> = flow {    var lastTime = 0L // 上次发射数据的时间    // 收集数据    collect { upstream ->        // 当前时间        val currentTime = System.currentTimeMillis()        // 时间差超过阈值则发送数据并记录时间        if (currentTime - lastTime > thresholdMillis) {            lastTime = currentTime            emit(upstream)        }    }}