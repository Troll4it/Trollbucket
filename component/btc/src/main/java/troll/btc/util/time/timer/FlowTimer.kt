package troll.btc.util.time.timerimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.Jobimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.flowOnimport kotlinx.coroutines.flow.launchInimport kotlinx.coroutines.flow.onCompletionimport kotlinx.coroutines.flow.onEachimport kotlinx.coroutines.flow.onStart/** * author : TangPeng * date : 11/22/22 14:35 * description : Flow版本的倒计时 */class FlowTimer(    private var total: Int,    scope: CoroutineScope,    private var interval: Int = 1000,    private var reverse: Boolean = false,    private var onStart: (() -> Unit)? = null,    private var onTick: ((Int) -> Unit?)? = null,    private var onStop: (() -> Unit)? = null,    private var onFinish: (() -> Unit)? = null,    private var onCancel: (() -> Unit)? = null) : CountDownTimerImpl {    private var remainingTime: Int = 0    private var scope: CoroutineScope? = scope    private var job: Job? = null    private var stop = false    private var cancel = false    override fun start() {        resetConfig()        buildJob(1, total)    }    override fun reStart() {        if (cancel) {            buildJob(1, total)        } else if (stop) {            buildJob(remainingTime, total)        }        resetConfig()    }    override fun cancel() {        cancel = true        job?.cancel()    }    override fun stop() {        stop = true        job?.cancel()    }    override fun finish() {        job?.cancel()    }    private fun buildJob(start: Int, end: Int) {        scope?.let { scope ->            job = flow {                if (reverse) {                    for (i in end downTo start) {                        emit(i)                        kotlinx.coroutines.delay(interval.toLong())                    }                } else {                    for (i in start..end) {                        emit(i)                        kotlinx.coroutines.delay(interval.toLong())                    }                }            }.flowOn(Dispatchers.Main).onStart {                if (stop.not()) {                    onStart?.invoke()                }            }.onCompletion {                if (cancel) {                    onCancel?.invoke()                } else if (stop) {                    onStop?.invoke()                } else {                    onFinish?.invoke()                }            }.onEach {                remainingTime = it                onTick?.invoke(it)            }.launchIn(scope)        }    }    private fun resetConfig() {        stop = false        cancel = false    }}