package troll.eth.ui.webimport android.content.Contextimport android.net.http.SslErrorimport android.webkit.*import androidx.appcompat.app.AlertDialogimport com.bumptech.glide.Glideimport kotlinx.coroutines.runBlockingimport okio.ByteString.Companion.encodeUtf8import java.io.File/** * author : TangPeng * date : 12/5/22 14:32 * description : */class BaseWebViewClient : WebViewClient() {    override fun onReceivedSslError(view: WebView?, handler: SslErrorHandler?, error: SslError?) {        view?.context?.let {            AlertDialog.Builder(it)                .setTitle("提示")                .setMessage("当前网站安全证书已过期或不可信\n是否继续浏览?")                .setPositiveButton("继续浏览") { dialog, _ ->                    dialog?.dismiss()                    handler?.proceed()                }                .setNegativeButton("返回上一页") { dialog, _ ->                    dialog?.dismiss()                    handler?.cancel()                }                .create()                .show()        }    }    override fun onReceivedError(        view: WebView?,        request: WebResourceRequest?,        error: WebResourceError?    ) {        if (request?.isForMainFrame == true) {            onReceivedError(                view,                error?.errorCode ?: 0,                error?.description.toString(),                request.url.toString()            )        }    }    override fun shouldInterceptRequest(        view: WebView?,        request: WebResourceRequest?    ): WebResourceResponse? {        if (view == null || request == null) return null        var webResourceResponse: WebResourceResponse? = null        // assets目录下的文件        if (isAssetsResource(request)) {            webResourceResponse = assetsResourceRequest(view.context, request)        }        // 使用下载图片        if (isCacheResource(request)) {            cacheResourceRequest(view.context, request)        }        if (webResourceResponse == null) {            webResourceResponse = super.shouldInterceptRequest(view, request)        }        return webResourceResponse    }    private fun cacheResourceRequest(        context: Context,        webRequest: WebResourceRequest    ): WebResourceResponse? {        var url = webRequest.url.toString()        var mimeType = getMimeTypeFromUrl(url)        // WebView 中的图片利用 Glide 加载(能够和App其他页面共用缓存)        if (isImageResource(webRequest)) {            return try {                val file = Glide.with(context).download(url).submit().get()                val webResourceResponse = WebResourceResponse(mimeType, "UTF-8", file.inputStream())                webResourceResponse.responseHeaders = mapOf("access-control-allow-origin" to "*")                webResourceResponse            } catch (e: Exception) {                e.printStackTrace()                null            }        }        /**         * 其他文件缓存逻辑         * 1.寻找缓存文件，本地有缓存直接返回缓存文件         * 2.无缓存，下载到本地后返回         * 注意！！！         * 一定要确保文件下载完整，我这里采用下载完成后给文件加 "success-" 前缀的方法         */        val webCachePath = WebUtil.getWebViewCachePath(context)        val cacheFilePath =            webCachePath + File.separator + "success-" + url.encodeUtf8().md5().hex() // 自定义文件命名规则        val cacheFile = File(cacheFilePath)        if (!cacheFile.exists() || !cacheFile.isFile) { // 本地不存在 则开始下载            // 下载文件            val sourceFilePath = webCachePath + File.separator + url.encodeUtf8().md5().hex()            val sourceFile = File(sourceFilePath)            runBlocking {                try {                    // todo 下载服务                    sourceFile.renameTo(cacheFile)                } catch (e: Exception) {                    e.printStackTrace()                    // 发生异常删除文件                    sourceFile.deleteOnExit()                    cacheFile.deleteOnExit()                }            }        }        // 缓存文件存在则返回        if (cacheFile.exists() && cacheFile.isFile) {            val webResourceResponse =                WebResourceResponse(mimeType, "UTF-8", cacheFile.inputStream())            webResourceResponse.responseHeaders = mapOf("access-control-allow-origin" to "*")            return webResourceResponse        }        return null    }    private fun isImageResource(webRequest: WebResourceRequest): Boolean {        val url = webRequest.url.toString()        val extension = MimeTypeMap.getFileExtensionFromUrl(url)        return extension == "ico" || extension == "bmp" || extension == "gif"                || extension == "jpeg" || extension == "jpg" || extension == "png"                || extension == "svg" || extension == "webp"    }    private fun isCacheResource(webRequest: WebResourceRequest): Boolean {        val url = webRequest.url.toString()        val extension = MimeTypeMap.getFileExtensionFromUrl(url)        return extension == "ico" || extension == "bmp" || extension == "gif"                || extension == "jpeg" || extension == "jpg" || extension == "png"                || extension == "svg" || extension == "webp" || extension == "css"                || extension == "js" || extension == "json" || extension == "eot"                || extension == "otf" || extension == "ttf" || extension == "woff"    }    private fun isAssetsResource(webRequest: WebResourceRequest): Boolean {        val url = webRequest.url.toString()        return url.startsWith("file:///android_asset/")    }    private fun assetsResourceRequest(        context: Context,        webRequest: WebResourceRequest    ): WebResourceResponse {        val url = webRequest.url.toString()        val fileNameIndex = url.lastIndexOf("/").plus(1)        val fileName = url.substring(fileNameIndex)        val suffixIndex = url.lastIndexOf(".")        val suffix = url.substring(            suffixIndex.plus(                1            )        )        val webResourceResponse = WebResourceResponse(            getMimeTypeFromUrl(url),            "UTF-8",            context.assets.open("$suffix/$fileName")        )        webResourceResponse.responseHeaders = mapOf("access-control-allow-origin" to "*")        return webResourceResponse    }    /**     * 根据 url 获取文件类型     */    private fun getMimeTypeFromUrl(url: String): String {        try {            val extension = MimeTypeMap.getFileExtensionFromUrl(url)            if (extension.isNotBlank() && extension != "null") {                if (extension == "json") {                    return "application/json"                }                return MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension) ?: "*/*"            }        } catch (e: Exception) {            e.printStackTrace()        }        return "*/*"    }}