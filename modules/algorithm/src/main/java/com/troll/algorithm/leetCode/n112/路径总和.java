package com.troll.algorithm.leetCode.n112;import com.troll.algorithm.二叉树.TreeNode;import java.util.Stack;/** * author : TangPeng * date : 11/12/22 20:43 * description : */public class 路径总和 {    public boolean hasPathSum(TreeNode root, int targetSum) {        if (root == null) return false;        targetSum -= root.val;        // 叶子结点 (如果是到叶子结点，直接判断结果是不是为0)        if (root.left == null && root.right == null) {            return targetSum == 0;        }        if (root.left != null) { //            boolean left = hasPathSum(root.left, targetSum);            if (left) { // 左边找打                return true;            }        }        if (root.right != null) { //            boolean right = hasPathSum(root.right, targetSum);            if (right) { // 左边找打                return true;            }        }        return false;    }    public boolean hasPathsum(TreeNode root, int targetsum) {        if (root == null) return false;        Stack<TreeNode> stackNode = new Stack<>();        Stack<Integer> stackValue = new Stack<>();        stackNode.push(root);        stackValue.push(root.val);        while (!stackNode.isEmpty()) {            int size = stackNode.size();            for (int i = 0; i < size; i++) {                TreeNode node = stackNode.pop();                Integer sum = stackValue.pop();                // 如果该节点是叶子结点                if (node.left == null && node.right == null && sum == targetsum) return true;                // 右结点                if (node.right != null) {                    stackNode.push(node.right);                    stackValue.push(sum + node.right.val);                }                // 左结点                if (node.left != null) {                    stackNode.push(node.left);                    stackValue.push(sum + node.left.val);                }            }        }        return false;    }}