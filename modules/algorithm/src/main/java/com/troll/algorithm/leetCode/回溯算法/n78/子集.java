package com.troll.algorithm.leetCode.回溯算法.n78;import java.util.ArrayList;import java.util.Arrays;import java.util.LinkedList;import java.util.List;/** * author : TangPeng * date : 3/20/22 16:04 * description : * 给你一个整数数组num,数组中的元素互不相同，返回改数组所有可能的子集。 */public class 子集 {    static class Solution {        public static void main(String[] args) {            subsets(new int[]{1});        }        static List<List<Integer>> result = new ArrayList<>(); // 存放符合条件结果的集合        static LinkedList<Integer> path = new LinkedList<>();// 用来存放符合条件结果        public static List<List<Integer>> subsets(int[] nums) {            if (nums.length == 0) { // 空集合                result.add(new ArrayList<>());                return result;            }            subsetHelper(nums, 0);            System.out.println("result = " + Arrays.toString(new List[]{result})  );            return result;        }        /**         *         * path = [[1]], startIndex = 0z         * path = [[2]], startIndex = 0         * path = [[3]], startIndex = 0         *         * 1         *         * path = [[2]], startIndex = 1         * path = [[3]], startIndex = 1         *         * 2         * path = [[3]], startIndex = 2         * @param nums         * @param startIndex [[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]]         */        private static void subsetHelper(int[] nums, int startIndex) {            result.add(new ArrayList<>(path)); // 遍历树的树，把所有的结点都记录下来，这个就是要求的子集集合            if (startIndex >= nums.length) {// 终止条件                return;            }            for (int i = startIndex; i < nums.length; i++) {                path.add(nums[i]);                subsetHelper(nums, i + 1);                System.out.println("path= " + Arrays.toString(new List[]{path}) + ", startIndex = " +startIndex);                path.removeLast();// 回溯过程            }        }    }}