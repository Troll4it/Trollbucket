package com.troll.algorithm.leetCode.n513;import com.troll.algorithm.二叉树.TreeNode;import java.util.LinkedList;import java.util.Queue;/** * author : TangPeng * date : 11/11/22 22:43 * description : */public class 找树左下角的值 {    private int deep = -1;    private int value = 0;    /**     * 递归法     */    public int findBottomLeftValue(TreeNode root) {        value = root.val;        finalLeftValue(root, 0);        return value;    }    private void finalLeftValue(TreeNode root, int de) {        if (root == null) return;        if (root.left == null && root.right == null) {            if (de > deep) {                value = root.val;                deep = de;            }        }        if (root.left != null) finalLeftValue(root.left, de + 1);        if (root.right != null) finalLeftValue(root.right, de + 1);    }    /**     * 迭代法(使用层级遍历)，记录最后一行第一个节点就可以     */    public int findBottomLeft(TreeNode root) {        Queue<TreeNode> queue = new LinkedList<>();        queue.offer(root);        int res = 0;        while (!queue.isEmpty()) {            int size = queue.size();            for (int i = 0; i < size; i++) {                TreeNode poll = queue.poll();                assert poll != null;                if (i == 0) {                    res = poll.val;                }                if (poll.left != null) {                    queue.offer(poll.left);                }                if (poll.right != null) {                    queue.offer(poll.right);                }            }        }        return res;    }}