package troll.mviimport android.view.LayoutInflaterimport androidx.activity.viewModelsimport troll.btc.extensions.viewBindingimport troll.eth.base.viewbinding.BaseActivityimport troll.mvi.databinding.ActivityMviBinding/** * MVI 模式 * * 界面层：在屏幕上显示应用数据  UI Layer  = UI Element + UI State *      UI 元素： *      ViewModel:  View的State * * * *  网域层：  Domain Layer *  负责封装复杂的业务逻辑。由多个ViewModel重复使用的简单业务逻辑。 * *  优势： *  1. 避免代码重复 *  2. 使用网域层类的类的可读性 *  3. 改善应用的可测试性 * *  命名： FormatDateUseCase  这是网域层：下面可以拥有很多个Repo *        NewsRepository * * * 数据层：提供所需要的应用数据  Data Layer *    1. 获取到应用数据，将其转换成UI，并转换成UI STATE *    2. 通过订阅的方法，页面发生变化的时候，定时刷新UI *   将数据，转化成UI的状态的数据 *   接收到UI层操作，将其转换成对应的UI 状态数据， 然后去驱动UI层做出改变 * * * * *   单向数据流动： *   1. 数据一致性。界面的数据只有一个可信来源 *   2. 可测试行。状态来源是独立的，可独立于界面进行测试 *   3. 可维护性。状态的更改遵循明确定义的模式。状态更改是用户事件及其数据拉取来源共同作用的结果、 * * */class MviBaseActivity : BaseActivity<ActivityMviBinding>() {    override fun getBinding(inflater: LayoutInflater): ActivityMviBinding = ActivityMviBinding.inflate(inflater)    override fun flowData() {    }    private fun renderViewEvent(it: MviViewEvent) {        when (it) {            is MviViewEvent.ShowTitle -> {            }        }    }    override fun flowView() {    }}