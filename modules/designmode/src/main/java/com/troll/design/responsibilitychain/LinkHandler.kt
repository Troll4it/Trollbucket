package com.troll.design.responsibilitychainimport com.troll.design.responsibilitychain.link.Handlerimport com.troll.design.responsibilitychain.list.IHandlerclass LinkHandler {    private var list = arrayListOf<Handler>()    fun addHandler(handler: Handler) {        list.add(handler)    }    fun handle() {        list.forEach {        }    }}class ListHandler {    private val list = arrayListOf<IHandler>()    fun addHandler(handler: IHandler) {        list.add(handler)    }    fun handle() {        list.forEach {            it.handle()        }    }}class TestChain {    companion object {        @JvmStatic        fun main(args: Array<String>) {//            val link = LinkHandler()//            link.addHandler(HandlerA())//            link.addHandler(HandlerB())//            link.handle()            val list = ListHandler()            list.addHandler(com.troll.design.responsibilitychain.list.HandlerA())            list.addHandler(com.troll.design.responsibilitychain.list.HandlerB())            list.addHandler(com.troll.design.responsibilitychain.list.HandlerC())            list.handle()        }    }    // 如何应对代码复杂性 : 将大块代码逻辑拆分成函数，将大类拆分成小类。这样应用责任链模式，可以根据需求划分不同类    // 如何让代码满足开闭原则，提高代码的可拓展性：增加新的处理、或者逻辑判断可以在链条的前面或者后面添加// （前面增加逻辑，可以对现有的后面链条中部分进行修改实现代码逻辑修改），不对现有的修改// ，这样实现了开闭的原则}