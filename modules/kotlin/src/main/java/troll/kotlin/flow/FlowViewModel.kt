package troll.kotlin.flowimport androidx.lifecycle.viewModelScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.channels.BufferOverflowimport kotlinx.coroutines.channels.awaitCloseimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.*import kotlinx.coroutines.launchimport kotlinx.coroutines.withContextimport troll.btc.extensions.Liveimport troll.eth.base.viewbinding.BaseViewModel/** * author : TangPeng * date : 5/12/22 08:54 * description : */class FlowViewModel : BaseViewModel() {    private val TAG = "Flow流"    /**     * 流的创建     */    fun flowCreate() {        flowOf(1, 3, 3)        listOf(1, 2, 3, 4).asFlow()        flow {            emit(1)        }        // TODO:  回调改造使用的callbackFlow        callbackFlow {            send(1)            awaitClose { }        }        // TODO: 在flow中不允许切换线程，但是在channelFlow中允许        channelFlow {            send(1)            withContext(Dispatchers.IO) {                send(2)            }        }    }    /**     * 流的监听     */    private val monitorFlow = flow<Int> {        emit(1)        delay(100)        emit(1)        delay(100)        delay(100)        delay(100)        delay(100)        delay(100)        emit(1)        emit(1)        emit(1)        emit(1)        println(TAG.plus("数据流发送 1"))//        delay(1000)        emit(2)        delay(100)        emit(2)        emit(2)        emit(2)        emit(2)        println(TAG.plus("数据流发送 2"))//        delay(1000)        emit(3)        delay(100)        delay(100)        delay(100)        delay(100)        delay(100)        emit(3)        emit(3)        emit(3)        println(TAG.plus("数据流发送 3"))//        delay(1000)        emit(4)        emit(4)        emit(4)        emit(4)        emit(4)        emit(4)        println(TAG.plus("数据流发送 4"))    }    /**     * 提供末端操作符来触发     */    fun monitorFlow() {        viewModelScope.launch {            monitorFlow.collect {                println("流的监听$it")            }        }    }    /**     * 流的取消     */    fun cancelFlow() {        viewModelScope.launch {            val job = monitorFlow.onEach {                println("$TAG 流的取消 $it")            }.launchIn(viewModelScope)            delay(2500)            job.cancel()        }    }    /**     * 流的异常     */    fun flowException() {        monitorFlow.catch {            //        }    }    /**     * 背压     */    suspend fun flowBuffer() {        monitorFlow.onEach {        }.buffer(capacity = 2, onBufferOverflow = BufferOverflow.DROP_LATEST)            .retry(2)            .collect {            }    }    /**     * 数据防抖     */    fun distinctUntilChanged() {        viewModelScope.launch {            monitorFlow.distinctUntilChanged().collect {                println(TAG + "数据防抖$it")            }        }    }    val stateFlow = MutableStateFlow("初始值")    fun testStateFlow(value: String) {        stateFlow.value = value    }    val liveTest = Live<String>()    fun testLive(string: String) {        liveTest.value = string    }}