package troll.kotlin.flowimport kotlinx.coroutines.asyncimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.MutableStateFlowimport kotlinx.coroutines.runBlockingimport kotlinx.coroutines.selects.selectimport troll.eth.base.viewbinding.BaseViewModel/** * author : TangPeng * date : 5/28/22 15:44 * description : * * 场景：需要更新一个UI数据：获取缓存数据和网络数据，但是必须保证最终选择网络数据 * * 方案1： 先获取缓存信息，成功或者失败，再获取网络数据，这样一定能保证最终获取到网络数据 *    缺点：时间长 * 方案2： 并发获取缓存数据和网络数据，通过标识符，如果网络数据先于缓存回来，切断缓存信息更新UI的数据 * * */class SelectViewModel : BaseViewModel() {    val flowInfo = MutableStateFlow("默认参数")    /**     * 缓存的信息     */    suspend fun getCacheInfo(): SelectInfo {        delay(1000)        return SelectInfo("缓存信息", true)    }    /**     * 获取网络数据     */    suspend fun getNetInfo(): SelectInfo {        println("lifecycleScope 请求网络 ")        delay(6000)        return SelectInfo("网络信息", false)    }    /**     * select 选择了一个最快的     */    fun getInfo() {        runBlocking {            val startTime = System.currentTimeMillis()            val cacheDeferred = async { getCacheInfo() }            val netDeferred = async { getNetInfo() }            netDeferred.await()            val info = select<SelectInfo> {                cacheDeferred.onAwait {                    it                }                netDeferred.onAwait {                    it                }            }            flowInfo.value = info.info            if (info.cache) {                flowInfo.value = netDeferred.await().info            }        }    }}data class SelectInfo(var info: String, var cache: Boolean)