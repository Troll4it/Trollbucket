package troll.kotlin.dagimport troll.eth.base.viewbinding.BaseViewModelimport java.util.*/** * author : TangPeng * date : 3/7/22 09:55 * description : * 图相关知识： *  顶点：图中的点 *  边：连接两个顶点的线段 *  入度：当前有多少边指向它 * *  拓扑排序：对一个有向图构造拓扑序列的过程 *     * 每个顶点出现且只出现一次 *     * 若存在一条从顶点A到顶点B的路径，序列中顶点A出现顶点B的前面 */class DagViewModel : BaseViewModel() {    /**     * bfs 算法     *     *     */    fun bfs(num: Int, prerequisites: Array<IntArray>): Array<Int> {        // 计算所有节点的入度，好用数组代表哈希表，key是index，value是inDegree[index]        val inDegree = IntArray(num)        prerequisites.forEach {            inDegree[it[0]]++        }        // 找到所有入度为0的点，加入到队列当中        val queue: Queue<Int> = ArrayDeque()        inDegree.forEach {            if (it == 0) {                queue.add(it)            }        }        val result = arrayListOf<Int>()        while (!queue.isEmpty()) {            val key = queue.poll()            result.add(key)            // 遍历所有的            prerequisites.forEach {                // 改课程依赖当前课程key                if (key == it[1]) {                    // 入度减1                    inDegree[it[0]]--                    if (inDegree[it[0]] == 0) {                        queue.offer(it[0]) // 加入到队列中                    }                }            }        }        // 数量不相等，存在环        if (result.size != num) {            return emptyArray()        }        val array = arrayOf(num)        var index = 0        result.forEach {            array[index++] = it        }        return array    }    /**     * dfs算法     */    fun dfs() {    }}