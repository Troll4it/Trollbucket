package troll.kotlin.coroutinesimport kotlinx.coroutines.*import kotlin.system.measureTimeMillisclass CoroutinesClazz {    companion object {        @JvmStatic        fun main(args: Array<String>) = runBlocking {//            start()//            coroutinesCancel()//            canCancel()//            timeOut()//            async()            dispatchers()        }        //        fun dispatchers() {            runBlocking {                launch(Dispatchers.Unconfined) { // 非受限的——将和主线程一起工作                    println("Unconfined      : I'm working in thread ${Thread.currentThread().name}")                    delay(500)                    println("Unconfined      : After delay in thread ${Thread.currentThread().name}")                }                launch { // 父协程的上下文，主 runBlocking 协程                    println("main runBlocking: I'm working in thread ${Thread.currentThread().name}")                    delay(1000)                    println("main runBlocking: After delay in thread ${Thread.currentThread().name}")                }            }        }        // 使用 async 并发        suspend fun async() {            runBlocking {                val time = measureTimeMillis {                    val deferred = async { doSomethingUsefulOne() }                    val two = async { doSomethingUsefulTwo() }                    println("答案：${deferred.await()} + ${two.await()}")                }                println("总耗时 $time")            }        }        suspend fun doSomethingUsefulOne(): Int {            delay(1000)            return 19        }        suspend fun doSomethingUsefulTwo(): Int {            delay(1000)            return 40        }        // 协程的启动        fun start() {            GlobalScope.launch { // 在后台启动一个新的协程                println("World")            }            println("Hello")            // 这里为什么需要阻塞主线程 来保证JVM存活 ？？？？？？？才能打印出World            Thread.sleep(2000)        }        /**         * 协程取消         */        private fun coroutinesCancel() = runBlocking {            val startTime = System.currentTimeMillis()            val job = launch(Dispatchers.Default) {                var nextPrintTime = startTime                var i = 0                while (i < 5) { // 可以被取消的计算循环                    // 每秒打印消息两次                    if (System.currentTimeMillis() >= nextPrintTime) {                        println("job: I'm sleeping ${i++} ... $isActive")                        nextPrintTime += 500L                    }                }            }            delay(1300L) // 等待一段时间            println("main: I'm tired of waiting!")            job.cancelAndJoin() // 取消该作业并等待它结束            println("main: Now I can quit.")        }        fun canCancel() = runBlocking {            val job = launch {                try {                    repeat(100) {                        println(" 不能被取消 $it")                    }                } finally {                    withContext(NonCancellable) {                        println(" finally ")                        delay(1000)                        println("Job : 协程 运行到finally 不能被取消")                    }                }            }            delay(500)            println("主线程：开始等待")            job.cancelAndJoin()            println("主线程：开始退出")        }        fun timeOut() = runBlocking {            withTimeout(1000) {                repeat(100) {                    println("超时 $it")                    delay(100)                }            }        }    }}