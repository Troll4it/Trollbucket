package troll.kotlin.coroutinesimport androidx.lifecycle.viewModelScopeimport kotlinx.coroutines.*import kotlinx.coroutines.flow.asFlowimport kotlinx.coroutines.flow.catchimport kotlinx.coroutines.flow.flowOnimport kotlinx.coroutines.flow.onCompletionimport troll.btc.extensions.Liveimport troll.eth.base.viewbinding.BaseViewModelclass CoroutinesViewModel : BaseViewModel() {    private val scope = MainScope()    val liveTest = Live<String>()    fun test() {        scope.launch {            val one = getResult(10)            val two = getResult(20)            liveTest.value = one.plus(two).toString()        }        viewModelScope.launch {        }        val launch = GlobalScope.launch {        }    }    /**     * Flow的特点     * 冷流：     * 有序：     * 协作取消： 未知     *     */    fun testFlow() {        viewModelScope.launch(Dispatchers.Main) {            (1..10).asFlow() // 发射数据                .flowOn(Dispatchers.IO) // 将数据发射的操作放在 IO 线程中的协程                .catch {  // 捕获异常                }                .onCompletion {  // 完成回调                }                .collect { // 消费数据                    // 改变消费数据的线程   Flow的消费线程在我们 **启动协程** 指定调度器的时候就确认好，对应启动协程的调度器                }        }    }    suspend fun getResult(num: Int): Int {        delay(1000)        return num * num    }    override fun onDestroy() {        super.onDestroy()        scope.cancel()    }    /**     * 多协程数据处理的时候，原子性同样不能得到保证，协程出现   Mutex的锁     */}