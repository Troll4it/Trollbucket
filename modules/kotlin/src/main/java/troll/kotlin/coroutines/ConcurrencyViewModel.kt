package troll.kotlin.coroutinesimport androidx.lifecycle.LifecycleCoroutineScopeimport kotlinx.coroutines.*import kotlinx.coroutines.sync.Muteximport kotlinx.coroutines.sync.withLockimport java.util.concurrent.Executors/** * author : TangPeng * date : 3/15/23 17:21 * description : */class ConcurrencyViewModel {    val single = Executors.newSingleThreadExecutor {        Thread(it, "MySingleThread").apply { isDaemon = true }    }.asCoroutineDispatcher()    /**     * 单线程     */    suspend fun singleThread(lifecycleCoroutineScope: LifecycleCoroutineScope) {        var i = 0        val jobs = mutableListOf<Job>()        lifecycleCoroutineScope.apply {            repeat(10) {                val job = launch(single) {                    repeat(1000) {                        i++                    }                }                jobs.add(job)            }            jobs.joinAll()        }    }    fun mutex() {        runBlocking {            val mutex = Mutex()            var i = 0            val jobs = mutableListOf<Job>()            repeat(10) {                val job = launch(Dispatchers.Default) {                    repeat(1000) {                        mutex.withLock {                            i++                        }                    }                }                jobs.add(job)            }            jobs.joinAll()        }    }}